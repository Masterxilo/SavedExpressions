System`HoldComplete[System`CompoundExpression[Global`RedefinePublicFunction[System`List[], Global`IntegralSubstitute[System`HoldPattern[System`Pattern[Global`t, System`Blank[]][System`Integrate[System`Pattern[Global`fx, System`Blank[]], System`List[System`Pattern[Global`x, System`Blank[]], System`Pattern[Global`a, System`Blank[]], System`Pattern[Global`b, System`Blank[]]]]]], System`Pattern[Global`\[CurlyPhi], System`Blank[]]], "implements integral substitution for a single variable for the pure function \[CurlyPhi]:\n\n\!\(\*TagBox[\n RowBox[{SubsuperscriptBox[\"\[Integral]\", \"a\", \"b\"], \n  RowBox[{\n   RowBox[{\"f\", \"[\", \"x\", \"]\"}], \n   RowBox[{\"\[DifferentialD]\", \"x\"}]}]}],\n HoldForm]\)==\!\(\*TagBox[\n RowBox[{SubsuperscriptBox[\"\[Integral]\", \n   RowBox[{TagBox[SuperscriptBox[\"\[CurlyPhi]\", \n      RowBox[{\"(\", \n       RowBox[{\"-\", \"1\"}], \")\"}]],\n     InverseFunction,\nEditable->False], \"@\", \"a\"}], \n   RowBox[{TagBox[SuperscriptBox[\"\[CurlyPhi]\", \n      RowBox[{\"(\", \n       RowBox[{\"-\", \"1\"}], \")\"}]],\n     InverseFunction,\nEditable->False], \"@\", \"b\"}]], \n  RowBox[{\n   RowBox[{\"f\", \"[\", \n    RowBox[{\"\[CurlyPhi]\", \"[\", \"x\", \"]\"}], \"]\"}], \n   RowBox[{\n    RowBox[{\"\[CurlyPhi]\", \"'\"}], \"[\", \"x\", \"]\"}], \n   RowBox[{\"\[DifferentialD]\", \"x\"}]}]}],\n HoldForm]\)\n\nNote that the derivative and inverse of the function must be computable.\n\nThis is the left-to-right rule in Wikipedia.\n\nNote that this function allows having a wrapper such as Hold around the Integral. It will evaluate all inner function applications though", System`With[System`List[System`Set[Global`ft, System`ReplaceAll[Global`fx, System`Rule[Global`x, System`Slot[1]]]]], System`List[System`Set[Global`f\[CurlyPhi]x, System`Function[Global`ft][Global`\[CurlyPhi][Global`x]]], System`Set[Global`d\[CurlyPhi]x, System`Derivative[1][Global`\[CurlyPhi]][Global`x]], System`Set[Global`ia, System`InverseFunction[Global`\[CurlyPhi]][Global`a]], System`Set[Global`ib, System`InverseFunction[Global`\[CurlyPhi]][Global`b]]], Global`t[System`Integrate[System`Times[Global`f\[CurlyPhi]x, Global`d\[CurlyPhi]x], System`List[Global`x, Global`ia, Global`ib]]]], System`Blank[], "", System`Rule[System`Options, System`OptionValue[Global`PRedefinePublicFunctionAlternatives, System`List[], System`Options]]], System`Module[System`List[Global`defineAlternative$], System`CompoundExpression[System`SetAttributes[Global`defineAlternative$, System`HoldAll], System`SetDelayed[Global`defineAlternative$[System`Pattern[Global`def$, System`Blank[]], System`Pattern[Global`separateUsage$, System`Blank[System`String]], System`Pattern[Global`body$, System`Blank[]]], Global`DefinePublicFunction[Global`def$, Global`separateUsage$, Global`body$, System`Blank[], ""]], System`SetDelayed[Global`defineAlternative$[System`Pattern[Global`def$, System`Blank[]], System`Pattern[Global`body$, System`Blank[]]], Global`DefinePublicFunction[Global`def$, "implements integral substitution for a single variable for the pure function \[CurlyPhi]:\n\n\!\(\*TagBox[\n RowBox[{SubsuperscriptBox[\"\[Integral]\", \"a\", \"b\"], \n  RowBox[{\n   RowBox[{\"f\", \"[\", \"x\", \"]\"}], \n   RowBox[{\"\[DifferentialD]\", \"x\"}]}]}],\n HoldForm]\)==\!\(\*TagBox[\n RowBox[{SubsuperscriptBox[\"\[Integral]\", \n   RowBox[{TagBox[SuperscriptBox[\"\[CurlyPhi]\", \n      RowBox[{\"(\", \n       RowBox[{\"-\", \"1\"}], \")\"}]],\n     InverseFunction,\nEditable->False], \"@\", \"a\"}], \n   RowBox[{TagBox[SuperscriptBox[\"\[CurlyPhi]\", \n      RowBox[{\"(\", \n       RowBox[{\"-\", \"1\"}], \")\"}]],\n     InverseFunction,\nEditable->False], \"@\", \"b\"}]], \n  RowBox[{\n   RowBox[{\"f\", \"[\", \n    RowBox[{\"\[CurlyPhi]\", \"[\", \"x\", \"]\"}], \"]\"}], \n   RowBox[{\n    RowBox[{\"\[CurlyPhi]\", \"'\"}], \"[\", \"x\", \"]\"}], \n   RowBox[{\"\[DifferentialD]\", \"x\"}]}]}],\n HoldForm]\)\n\nNote that the derivative and inverse of the function must be computable.\n\nThis is the left-to-right rule in Wikipedia.\n\nNote that this function allows having a wrapper such as Hold around the Integral. It will evaluate all inner function applications though", Global`body$, System`Blank[], ""]], System`Apply[Global`defineAlternative$, System`Unevaluated[System`List[System`List[Global`IntegralSubstitute[System`Pattern[Global`i, System`HoldPattern[System`Integrate[System`Pattern[Global`fx, System`Blank[]], System`List[System`Pattern[Global`x, System`Blank[]], System`Pattern[Global`a, System`Blank[]], System`Pattern[Global`b, System`Blank[]]]]]], System`Pattern[Global`\[CurlyPhi], System`Blank[]]], System`ReleaseHold[Global`IntegralSubstitute[System`Hold[Global`i], Global`\[CurlyPhi]]]]]], System`List[1]], System`Null]], System`Null]]